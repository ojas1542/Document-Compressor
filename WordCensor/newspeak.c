#include "ll.h"
#include "parser.h"
#include "providedCode/bf.h"
#include "providedCode/gs.h"
#include "providedCode/hash.h"
#include <ctype.h>
#include <getopt.h>
#include <inttypes.h>
#include <math.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define REG_SUCCESS 0
#define DEFAULT_HT_SIZE 10000
#define DEFAULT_BF_SIZE 1048576
#define BUF_SZ 64
#define WORD "[A-Za-zÀ-ÿ'_]+([-]?[A-Za-zÀ-ÿ])*"

#define OPTIONS "sh:f:mb"

// State variables for getopt flags
bool move_to_front = false;
bool b_selected = false;
uint32_t bf_size = 1048576;
uint32_t ht_size = 10000;
bool run_censor = true;
double hash_load = 0;
double bf_load = 0;

// Function copies string in lowercase
char *strLower(char *dest, char *src) {
  if (src != NULL) {
    for (uint32_t k = 0; k < strlen(src); k++) {
      dest[k] = tolower(src[k]);
    }
    dest[strlen(src)] = '\0';
  }
  return dest;
}

int main(int argc, char **argv) {
  int choice = 0;
  while ((choice = getopt(argc, argv, OPTIONS)) != -1) {
    switch (choice) {
    case 's':
      run_censor = false;
      break;
    case 'h':
      if ((int)atoi(optarg) < 2) { // Read input HT size
        printf("Please enter a number greater than 1 for hash table size\n");
        exit(-3);
      } else {
        ht_size = (uint32_t)atoi(optarg);
      }
      break;
    case 'f': // Read input BF size.
      if ((int)atoi(optarg) < 2) {
        printf("Please enter a number greater than 1 for bloom filter size\n");
        exit(-3);
      } else {
        bf_size = (uint32_t)atoi(optarg);
      }
      break;
    case 'm':
      move_to_front = true;
      break;
    case 'b':
      b_selected = true; // Set if -b flag passed in
      break;
    default:
      printf("Use README file for help with choosing options appropriately.\n");
      break;
    }
  }

  // Statement to check if both -b and -m flags are passed. Raises error if so.
  if (move_to_front && b_selected) {
    printf("Cannot pass in both -b and -m flags\n");
    exit(1);
  }

  // Create character buffer.
  char buf[BUF_SZ];
  // Initialize regex compiler with defined regular expression.
  regex_t regex;
  int rc;
  rc = regcomp(&regex, WORD, REG_EXTENDED);
  if (rc) {
    regerror(rc, &regex, buf, BUF_SZ);
    fprintf(stderr, "Regex compilation failed: %s\n", buf);
    exit(1);
  }

  BloomFilter *bf = bf_create(bf_size);
  HashTable *ht = ht_create(ht_size);
  FILE *badspeak = fopen("badspeak.txt", "r");
  char *forbidden_word = ".";
  char *store = NULL;
  // Following code reads from badspeak.txt
  while (forbidden_word != NULL) {
    forbidden_word = next_word(
        badspeak, &regex); // Read word from badspeak.txt given regular expr.
    if (forbidden_word != NULL) {
      store = (char *)malloc(strlen(forbidden_word) + 1);
      strLower(store, forbidden_word);
      bf_insert(bf, store); // Set bit at hash value index generated by string
                            // in bloom filter.
      GoodSpeak *gs = gs_create(store, NULL); // Create goodspeak struct with no
                                              // translation. (Creates copies of
                                              // string in constructor)
      ht_insert(ht, gs);                      // Insert in hash table.
      gs_delete(gs); // Delete temporary goodspeak struct.
    }
    free(store);
    store = NULL;
  }
  free(forbidden_word);
  forbidden_word = NULL;

  // Close badspeak file.
  fclose(badspeak);

  FILE *newspeak = fopen("newspeak.txt", "r"); // open newspeak.txt file
  char *word = ".";                            // Read word on left
  char *store_left = NULL;
  char *store_right = NULL;
  // Following code reads from newspeak.txt
  while (word != NULL) {
    word = next_word(
        newspeak,
        &regex); // read word from newspeak.txt given regular expression.
    if (word != NULL) {
      store_left = (char *)calloc(
          1, strlen(word) + 1);   // Allocate memory the size of word read
      strLower(store_left, word); // Copy from string read.
      bf_insert(bf, store_left);  // Set bit in bloom filter to hash value.
    }
    word = next_word(newspeak, &regex); // read word on right(translation)
    if (word != NULL) {
      store_right = (char *)calloc(
          1, strlen(word) + 1);    // Allocate mmeory to size of word read
      strLower(store_right, word); // Copy to string allocated.
    }
    if (word != NULL) {
      GoodSpeak *gs1 =
          gs_create(store_left, store_right); // Create goodspeak for given
                                              // translation. (Creates copies of
                                              // string in the constructor)
      // ll_node_print(ht_lookup(ht,"story"));

      ht_insert(ht, gs1); // Insert in hashtable
      gs_delete(gs1);     // delete temp goodspeak struct
      gs1 = NULL;

      // Free string variables allocated for next iteration.
      free(store_right);
      store_right = NULL;
      free(store_left);
      store_left = NULL;
    }
  }
  // ll_node_print(ht_lookup(ht,"story"));
  fclose(newspeak); // close newspeak.txt
  // Following code reads from either command line or text file to check if any
  // words match.
  FILE *message = stdin; // Default to standard input.
  char *uncensored_word = ".";
  uint32_t forbidden_count = 0; // Count number of forbidden words used.
  uint32_t old_count = 0;       // Count number of oldspeak words used.
  char *read = NULL;
  ListNode **forbidden = (ListNode **)calloc(
      1, sizeof(ListNode *)); // Linked list to store forbidden words used.
  ListNode **old = (ListNode **)calloc(
      1, sizeof(ListNode *)); // Linked list to store oldspeak words used.
  while (uncensored_word != NULL) {
    uncensored_word = next_word(
        message,
        &regex); // Read word from standard input given regular expression
    if (uncensored_word != NULL) {
      read = (char *)calloc(strlen(uncensored_word) + 1, sizeof(char));
      strLower(read, uncensored_word);
      if (bf_probe(bf, read) == true) { // Check if words might be there in
                                        // bloomfilter checking if bit = 1
        ListNode *node_word = ht_lookup(
            ht, read); // If it's in the bloomfilter, check in hash table
                       // ll_node_print(node_word);
        if (node_word !=
            NULL) { // iF node associate with oldspeak is in the hash table.
          if (node_word->gs->newspeak ==
              NULL) {          // If there is not translation for word.
            forbidden_count++; // Forbidden word detected. Increment.
            ll_insert(forbidden,
                      node_word->gs); // Insert in list of forbidden word nodes
          } else {                    // If translation exists.
            old_count++;              // Old word detected. Increment.
            ll_insert(old, node_word->gs); // Insert in list of old word nodes.
          }
        }
      }
    }
    free(read);
    read = NULL;
  }

  fclose(message);

  // Code for to determine output based on flags and input text.
  if (run_censor) { // run_censor only true if -s flag not present.
    if (forbidden_count > 0 && old_count == 0) { // if only forbidden words
                                                 // used.
      printf("Dear Comrade,\n\n");
      printf("You have chosen to use degenerate words that may cause hurt\n");
      printf("feelings or cause your comrades to think unpleasant thoughts.\n");
      printf("This is doubleplus bad. To correct your wrongthink and\n");
      printf(
          "preserve community consensus we will be sending you to joycamp\n");
      printf("administered by Miniluv.\n\n");

      // Print forbidden word from each node.
      printf("Your errors:\n\n");
      ListNode *iterator0a = *forbidden;
      while (iterator0a != NULL) {
        ll_node_print(iterator0a);
        printf("\n");
        iterator0a = iterator0a->next;
      }
    } else if (old_count > 0 &&
               forbidden_count == 0) { // if only oldspeak words used.
      printf("Dear Comrade,\n\n");
      printf("Submitting your text helps to preserve feelings and prevent\n");
      printf("badthink. Some of the words that you used are not goodspeak.\n");
      printf(
          "The list shows how to turn the oldspeak words into newspeak.\n\n");

      // Print oldspeak words followed by translation by iterating over each
      // node in list.
      ListNode *iterator = *old;
      while (iterator != NULL) {
        ll_node_print(iterator);
        printf(" -> %s\n", gs_newspeak(iterator->gs));
        iterator = iterator->next;
      }
    } else if (old_count > 0 &&
               forbidden_count >
                   0) { // If both forbidden and oldspeak words are used.
      printf("Dear Comrade,\n\n");
      printf("You have chosen to use degenerate words that may cause hurt\n");
      printf("feelings or cause your comrades to think unpleasant thoughts.\n");
      printf("This is doubleplus bad. To correct your wrongthink and\n");
      printf(
          "preserve community consensus we will be sending you to joycamp\n");
      printf("administered by Miniluv.\n\n");

      // Print forbidden words used by linked list of forbidden nodes.
      printf("Your errors:\n\n");
      ListNode *iterator1a = *forbidden;
      while (iterator1a != NULL) {
        ll_node_print(iterator1a);
        printf("\n");
        iterator1a = iterator1a->next;
      }

      // Print oldspeak words followed by translation stored in oldspeak nodes.
      printf("\n");
      printf("Think of these words on your vacation!\n\n");
      ListNode *iterator1 = *old;
      while (iterator1 != NULL) {
        ll_node_print(iterator1);
        printf(" -> %s\n", gs_newspeak(iterator1->gs));
        iterator1 = iterator1->next;
      }
    }
  } else {
    // print statistics
    // Cast to double to print decimal percentages and values.
    double hash_count = (double)ht_count(ht);
    double b_count = (double)bf_count(bf);
    double h_size = (double)ht_size;
    double b_size = (double)bf_size;
    hash_load = 100 * (hash_count / h_size);
    bf_load = 100 * (b_count / b_size);
    printf("Seeks: %u\n", lookups);
    double seeks_d = (double)lookups;
    double links_d = (double)links;
    printf("Average seek length: %lf\n", links_d / seeks_d);

    printf("Hash table load: %lf%%\n", hash_load);
    printf("Bloom filter load: %lf%%\n", bf_load);
  }

  // Free memory allocated to ADTs
  bf_delete(bf);
  ht_delete(ht);
  ll_delete(*forbidden);
  free(forbidden);
  ll_delete(*old);
  free(old);
  regfree(&regex);

  return 0;
}
